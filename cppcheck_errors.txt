Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/archo.h:34:14: style: inconclusive: The member function 'ZArchO::BO' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
    uint32_t BO(uint32_t uVal);
             ^
Shared/Magic/zsign/archo.cpp:216:18: note: Technically the member function 'ZArchO::BO' can be const.
uint32_t ZArchO::BO(uint32_t uValue) { return m_bBigEndian ? LE(uValue) : uValue; }
                 ^
Shared/Magic/zsign/archo.h:34:14: note: Technically the member function 'ZArchO::BO' can be const.
    uint32_t BO(uint32_t uVal);
             ^
Shared/Magic/zsign/archo.h:35:17: performance: inconclusive: The member function 'ZArchO::GetFileType' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    const char *GetFileType(uint32_t uFileType);
                ^
Shared/Magic/zsign/archo.cpp:177:21: note: Technically the member function 'ZArchO::GetFileType' can be static (but you may consider moving to unnamed namespace).
const char *ZArchO::GetFileType(uint32_t uFileType) {
                    ^
Shared/Magic/zsign/archo.h:35:17: note: Technically the member function 'ZArchO::GetFileType' can be static (but you may consider moving to unnamed namespace).
    const char *GetFileType(uint32_t uFileType);
                ^
Shared/Magic/zsign/archo.h:36:17: performance: inconclusive: The member function 'ZArchO::GetArch' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    const char *GetArch(int cpuType, int cpuSubType);
                ^
Shared/Magic/zsign/archo.cpp:115:21: note: Technically the member function 'ZArchO::GetArch' can be static (but you may consider moving to unnamed namespace).
const char *ZArchO::GetArch(int cpuType, int cpuSubType) {
                    ^
Shared/Magic/zsign/archo.h:36:17: note: Technically the member function 'ZArchO::GetArch' can be static (but you may consider moving to unnamed namespace).
    const char *GetArch(int cpuType, int cpuSubType);
                ^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/archo.cpp:42:17: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    m_pHeader = (mach_header *)m_pBase;
                ^
Shared/Magic/zsign/archo.cpp:54:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:57:42: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                segment_command *seglc = (segment_command *)pLoadCommand;
                                         ^
Shared/Magic/zsign/archo.cpp:75:45: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                segment_command_64 *seglc = (segment_command_64 *)pLoadCommand;
                                            ^
Shared/Magic/zsign/archo.cpp:95:54: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                encryption_info_command *crypt_cmd = (encryption_info_command *)pLoadCommand;
                                                     ^
Shared/Magic/zsign/archo.cpp:101:48: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                codesignature_command *pcslc = (codesignature_command *)pLoadCommand;
                                               ^
Shared/Magic/zsign/archo.cpp:248:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:261:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:263:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            dylib_command *dlc = (dylib_command *)pLoadCommand;
                                 ^
Shared/Magic/zsign/archo.cpp:276:33: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            load_command *plc = (load_command *)pLoadCommand;
                                ^
Shared/Magic/zsign/archo.cpp:278:38: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                dylib_command *dlc = (dylib_command *)pLoadCommand;
                                     ^
Shared/Magic/zsign/archo.cpp:521:28: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    load_command *pseglc = (load_command *)m_pLinkEditSegment;
                           ^
Shared/Magic/zsign/archo.cpp:524:38: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            segment_command *seglc = (segment_command *)m_pLinkEditSegment;
                                     ^
Shared/Magic/zsign/archo.cpp:531:41: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            segment_command_64 *seglc = (segment_command_64 *)m_pLinkEditSegment;
                                        ^
Shared/Magic/zsign/archo.cpp:539:36: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    codesignature_command *pcslc = (codesignature_command *)m_pCodeSignSegment;
                                   ^
Shared/Magic/zsign/archo.cpp:546:17: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        pcslc = (codesignature_command *)(m_pBase + m_uHeaderSize + BO(m_pHeader->sizeofcmds));
                ^
Shared/Magic/zsign/archo.cpp:576:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:579:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            dylib_command *dlc = (dylib_command *)pLoadCommand;
                                 ^
Shared/Magic/zsign/archo.cpp:607:26: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    dylib_command *dlc = (dylib_command *)(m_pBase + m_uHeaderSize + BO(m_pHeader->sizeofcmds));
                         ^
Shared/Magic/zsign/archo.cpp:642:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:646:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            dylib_command *dlc = (dylib_command *)pLoadCommand;
                                 ^
Shared/Magic/zsign/archo.cpp:685:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:688:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            dylib_command *dlc = (dylib_command *)pLoadCommand;
                                 ^
Shared/Magic/zsign/archo.cpp:720:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        load_command *plc = (load_command *)pLoadCommand;
                            ^
Shared/Magic/zsign/archo.cpp:722:34: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            dylib_command *dlc = (dylib_command *)pLoadCommand;
                                 ^
Shared/Magic/zsign/archo.cpp:35:34: style: The unsigned expression 'uLength' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (NULL == pBase || uLength <= 0) {
                                 ^
Shared/Magic/zsign/archo.cpp:298:46: style: The unsigned expression 'm_uSignLength' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (NULL == m_pSignBase || m_uSignLength <= 0) {
                                             ^
Shared/Magic/zsign/archo.cpp:216:30: style: inconclusive: Function 'BO' argument 1 names different: declaration 'uVal' definition 'uValue'. [funcArgNamesDifferent]
uint32_t ZArchO::BO(uint32_t uValue) { return m_bBigEndian ? LE(uValue) : uValue; }
                             ^
Shared/Magic/zsign/archo.h:34:26: note: Function 'BO' argument 1 names different: declaration 'uVal' definition 'uValue'.
    uint32_t BO(uint32_t uVal);
                         ^
Shared/Magic/zsign/archo.cpp:216:30: note: Function 'BO' argument 1 names different: declaration 'uVal' definition 'uValue'.
uint32_t ZArchO::BO(uint32_t uValue) { return m_bBigEndian ? LE(uValue) : uValue; }
                             ^
Shared/Magic/zsign/archo.cpp:676:42: performance: Parameter 'dylibNames' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
void ZArchO::uninstallDylibs(set<string> dylibNames) {
                                         ^
Shared/Magic/zsign/archo.cpp:637:29: style: Variable 'oldPathPadding' is assigned a value that is never used. [unreadVariable]
    uint32_t oldPathPadding = (8 - oldPathLength % 8) % 8;
                            ^
Shared/Magic/zsign/archo.cpp:639:33: style: Variable 'newLoadCommandSize' is assigned a value that is never used. [unreadVariable]
    uint32_t newLoadCommandSize = 0;
                                ^
Shared/Magic/zsign/archo.cpp:628:0: style: The function 'ChangeDylibPath' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:34:0: style: The function 'Init' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:569:0: style: The function 'InjectDyLib' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:715:0: style: The function 'ListDylibs' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:225:0: style: The function 'PrintInfo' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:512:0: style: The function 'ReallocCodeSignSpace' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:474:0: style: The function 'Sign' is never used. [unusedFunction]

^
Shared/Magic/zsign/archo.cpp:676:0: style: The function 'uninstallDylibs' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/openssl.cpp:276:32: style: inconclusive: Function 'GenerateCMS' argument 4 names different: declaration 'strCDHashPlist' definition 'strCDHashesPlist'. [funcArgNamesDifferent]
                 const string &strCDHashesPlist, string &strCMSOutput) {
                               ^
Shared/Magic/zsign/openssl.h:17:32: note: Function 'GenerateCMS' argument 4 names different: declaration 'strCDHashPlist' definition 'strCDHashesPlist'.
                 const string &strCDHashPlist, string &strCMSOutput);
                               ^
Shared/Magic/zsign/openssl.cpp:276:32: note: Function 'GenerateCMS' argument 4 names different: declaration 'strCDHashPlist' definition 'strCDHashesPlist'.
                 const string &strCDHashesPlist, string &strCMSOutput) {
                               ^
Shared/Magic/zsign/openssl.cpp:486:26: style: Local variable 'obj' shadows outer variable [shadowVariable]
            ASN1_OBJECT *obj = X509_ATTRIBUTE_get0_object(attr);
                         ^
Shared/Magic/zsign/openssl.cpp:449:24: note: Shadowed declaration
    const ASN1_OBJECT *obj = CMS_get0_type(cms);
                       ^
Shared/Magic/zsign/openssl.cpp:486:26: note: Shadow variable
            ASN1_OBJECT *obj = X509_ATTRIBUTE_get0_object(attr);
                         ^
Shared/Magic/zsign/openssl.cpp:134:14: style: Variable 'code' is assigned a value that is never used. [unreadVariable]
    int code = BIO_puts(ldapbio, a.c_str());
             ^
Shared/Magic/zsign/openssl.cpp:275:0: style: The function 'GenerateCMS' is never used. [unusedFunction]

^
Shared/Magic/zsign/openssl.cpp:438:0: style: The function 'GetCMSInfo' is never used. [unusedFunction]

^
Shared/Magic/zsign/openssl.cpp:586:0: style: The function 'Init' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/bundle.h:36:10: performance: inconclusive: The member function 'ZAppBundle::GetSignFolderInfo' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    bool GetSignFolderInfo(const string &strFolder, JValue &jvNode, bool bGetName = false);
         ^
Shared/Magic/zsign/bundle.cpp:67:18: note: Technically the member function 'ZAppBundle::GetSignFolderInfo' can be static (but you may consider moving to unnamed namespace).
bool ZAppBundle::GetSignFolderInfo(const string &strFolder, JValue &jvNode, bool bGetName) {
                 ^
Shared/Magic/zsign/bundle.h:36:10: note: Technically the member function 'ZAppBundle::GetSignFolderInfo' can be static (but you may consider moving to unnamed namespace).
    bool GetSignFolderInfo(const string &strFolder, JValue &jvNode, bool bGetName = false);
         ^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/bundle.cpp:171:77: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
    for (set<string>::iterator it = setFiles.begin(); it != setFiles.end(); it++) {
                                                                            ^
Shared/Magic/zsign/bundle.cpp:423:0: style: The function 'SignFolder' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]

Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/macho.h:25:10: style: inconclusive: The member function 'ZMachO::PrintInfo' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
    void PrintInfo();
         ^
Shared/Magic/zsign/macho.cpp:110:14: note: Technically the member function 'ZMachO::PrintInfo' can be const.
void ZMachO::PrintInfo() {
             ^
Shared/Magic/zsign/macho.h:25:10: note: Technically the member function 'ZMachO::PrintInfo' can be const.
    void PrintInfo();
         ^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/macho.cpp:73:38: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            fat_header *pFatHeader = (fat_header *)m_pBase;
                                     ^
Shared/Magic/zsign/macho.cpp:76:38: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                fat_arch *pFatArch = (fat_arch *)(m_pBase + sizeof(fat_header) + sizeof(fat_arch) * i);
                                     ^
Shared/Magic/zsign/macho.cpp:184:29: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
        fat_header fath = *((fat_header *)m_pBase);
                            ^
Shared/Magic/zsign/macho.cpp:187:31: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
            fat_arch arch = *((fat_arch *)(m_pBase + sizeof(fat_header) + sizeof(fat_arch) * i));
                              ^
Shared/Magic/zsign/macho.cpp:99:36: style: The unsigned expression 'm_sSize' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (NULL == m_pBase || m_sSize <= 0) {
                                   ^
Shared/Magic/zsign/macho.cpp:166:24: style: The unsigned expression 'uNewLength' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (uNewLength <= 0) {
                       ^
Shared/Magic/zsign/macho.cpp:256:22: style: Unused variable: arrMachOesSizes [unusedVariable]
    vector<uint32_t> arrMachOesSizes;
                     ^
Shared/Magic/zsign/macho.cpp:40:0: style: The function 'Free' is never used. [unusedFunction]

^
Shared/Magic/zsign/macho.cpp:30:0: style: The function 'InitV' is never used. [unusedFunction]

^
Shared/Magic/zsign/macho.cpp:296:0: style: The function 'RemoveDylib' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/signing.cpp:428:18: style: Condition 'uVersion>=0x20100' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:428:18: note: Condition 'uVersion>=0x20100' is always true
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:431:18: style: Condition 'uVersion>=0x20200' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:431:18: note: Condition 'uVersion>=0x20200' is always true
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:434:18: style: Condition 'uVersion>=0x20300' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20300) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:434:18: note: Condition 'uVersion>=0x20300' is always true
    if (uVersion >= 0x20300) {
                 ^
Shared/Magic/zsign/signing.cpp:450:18: style: Condition 'uVersion>=0x20100' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:450:18: note: Condition 'uVersion>=0x20100' is always true
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:453:18: style: Condition 'uVersion>=0x20200' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:453:18: note: Condition 'uVersion>=0x20200' is always true
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:463:18: style: Condition 'uVersion>=0x20100' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:463:18: note: Condition 'uVersion>=0x20100' is always true
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:466:18: style: Condition 'uVersion>=0x20200' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:466:18: note: Condition 'uVersion>=0x20200' is always true
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:474:18: style: Condition 'uVersion>=0x20100' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:474:18: note: Condition 'uVersion>=0x20100' is always true
    if (uVersion >= 0x20100) {
                 ^
Shared/Magic/zsign/signing.cpp:477:18: style: Condition 'uVersion>=0x20200' is always true [knownConditionTrueFalse]
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: Assignment 'uVersion=0x20400', assigned value is 132096
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:477:18: note: Condition 'uVersion>=0x20200' is always true
    if (uVersion >= 0x20200) {
                 ^
Shared/Magic/zsign/signing.cpp:281:35: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_CodeDirectory cdHeader = *((CS_CodeDirectory *)pSlotBase);
                                  ^
Shared/Magic/zsign/signing.cpp:597:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_SuperBlob *psb = (CS_SuperBlob *)pCSBase;
                        ^
Shared/Magic/zsign/signing.cpp:605:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_SuperBlob *psb = (CS_SuperBlob *)pCSBase;
                        ^
Shared/Magic/zsign/signing.cpp:615:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_BlobIndex *pbi = (CS_BlobIndex *)(pCSBase + sizeof(CS_SuperBlob));
                        ^
Shared/Magic/zsign/signing.cpp:660:35: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_CodeDirectory cdHeader = *((CS_CodeDirectory *)pSlotBase);
                                  ^
Shared/Magic/zsign/signing.cpp:672:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_SuperBlob *psb = (CS_SuperBlob *)pCSBase;
                        ^
Shared/Magic/zsign/signing.cpp:677:25: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
    CS_BlobIndex *pbi = (CS_BlobIndex *)(pCSBase + sizeof(CS_SuperBlob));
                        ^
Shared/Magic/zsign/signing.cpp:682:47: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                CS_CodeDirectory cdHeader = *((CS_CodeDirectory *)pSlotBase);
                                              ^
Shared/Magic/zsign/signing.cpp:689:47: style: C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts. [cstyleCast]
                CS_CodeDirectory cdHeader = *((CS_CodeDirectory *)pSlotBase);
                                              ^
Shared/Magic/zsign/signing.cpp:438:18: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
    if (uVersion >= 0x20400) {
                 ^
Shared/Magic/zsign/signing.cpp:384:25: note: 'uVersion' is assigned value '0x20400' here.
    uint32_t uVersion = 0x20400;
                        ^
Shared/Magic/zsign/signing.cpp:438:18: note: The comparison 'uVersion >= 0x20400' is always true.
    if (uVersion >= 0x20400) {
                 ^
Shared/Magic/zsign/signing.cpp:380:42: style: The unsigned expression 'uCodeLength' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (NULL == pCodeBase || uCodeLength <= 0 || strBundleId.empty() || strTeamId.empty()) {
                                         ^
Shared/Magic/zsign/signing.cpp:666:0: style: The function 'GetCodeSignatureExistsCodeSlotsData' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:596:0: style: The function 'GetCodeSignatureLength' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:604:0: style: The function 'ParseCodeSignature' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:565:0: style: The function 'SlotBuildCMSSignature' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:373:0: style: The function 'SlotBuildCodeDirectory' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:253:0: style: The function 'SlotBuildDerEntitlements' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:237:0: style: The function 'SlotBuildEntitlements' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:140:0: style: The function 'SlotBuildRequirements' is never used. [unusedFunction]

^
Shared/Magic/zsign/signing.cpp:655:0: style: The function 'SlotGetCodeSlotsData' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

Shared/Magic/zsign/common/json.cpp:1136:12: warning: Either the condition 'len<=szbuf' is redundant or the array 'buf[512]' is accessed at index 512, which is out of bounds. [arrayIndexOutOfBoundsCond]
        buf[len] = 0;
           ^
Shared/Magic/zsign/common/json.cpp:1133:13: note: Assuming that condition 'len<=szbuf' is not redundant
    if (len <= szbuf) {
            ^
Shared/Magic/zsign/common/json.cpp:1136:12: note: Array index out of bounds
        buf[len] = 0;
           ^
Shared/Magic/zsign/common/json.cpp:1902:12: warning: Either the condition 'len<=szbuf' is redundant or the array 'buf[512]' is accessed at index 512, which is out of bounds. [arrayIndexOutOfBoundsCond]
        buf[len] = 0;
           ^
Shared/Magic/zsign/common/json.cpp:1899:13: note: Assuming that condition 'len<=szbuf' is not redundant
    if (len <= szbuf) {
            ^
Shared/Magic/zsign/common/json.cpp:1902:12: note: Array index out of bounds
        buf[len] = 0;
           ^
Shared/Magic/zsign/common/json.h:230:1: style: The class 'JReader' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JReader {
^
Shared/Magic/zsign/common/json.h:285:1: style: The class 'JWriter' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior. [noConstructor]
class JWriter {
^
Shared/Magic/zsign/common/json.h:179:10: performance: inconclusive: The member function 'JValue::WriteDataToFile' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    bool WriteDataToFile(const char *file, const char *data, size_t len);
         ^
Shared/Magic/zsign/common/json.cpp:753:14: note: Technically the member function 'JValue::WriteDataToFile' can be static (but you may consider moving to unnamed namespace).
bool JValue::WriteDataToFile(const char *file, const char *data, size_t len) {
             ^
Shared/Magic/zsign/common/json.h:179:10: note: Technically the member function 'JValue::WriteDataToFile' can be static (but you may consider moving to unnamed namespace).
    bool WriteDataToFile(const char *file, const char *data, size_t len);
         ^
Shared/Magic/zsign/common/json.h:370:10: performance: inconclusive: The member function 'PReader::decodeString' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    bool decodeString(Token &token, string &decoded, bool filter = true);
         ^
Shared/Magic/zsign/common/json.cpp:1912:15: note: Technically the member function 'PReader::decodeString' can be static (but you may consider moving to unnamed namespace).
bool PReader::decodeString(Token &token, string &strdec, bool filter) {
              ^
Shared/Magic/zsign/common/json.h:370:10: note: Technically the member function 'PReader::decodeString' can be static (but you may consider moving to unnamed namespace).
    bool decodeString(Token &token, string &decoded, bool filter = true);
         ^
Shared/Magic/zsign/common/json.h:381:10: performance: inconclusive: The member function 'PReader::byteConvert' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    void byteConvert(uint8_t *v, size_t size);
         ^
Shared/Magic/zsign/common/json.cpp:1974:15: note: Technically the member function 'PReader::byteConvert' can be static (but you may consider moving to unnamed namespace).
void PReader::byteConvert(uint8_t *v, size_t size) {
              ^
Shared/Magic/zsign/common/json.h:381:10: note: Technically the member function 'PReader::byteConvert' can be static (but you may consider moving to unnamed namespace).
    void byteConvert(uint8_t *v, size_t size);
         ^
Shared/Magic/zsign/common/json.h:75:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int val);
    ^
Shared/Magic/zsign/common/json.h:76:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(bool val);
    ^
Shared/Magic/zsign/common/json.h:77:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(double val);
    ^
Shared/Magic/zsign/common/json.h:78:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(int64_t val);
    ^
Shared/Magic/zsign/common/json.h:79:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const char *val);
    ^
Shared/Magic/zsign/common/json.h:80:5: style: Class 'JValue' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    JValue(const string &val);
    ^
Shared/Magic/zsign/common/json.cpp:2107:47: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
                    pv = static_cast<double>(*reinterpret_cast<float*>(buf));
                                              ^
Shared/Magic/zsign/common/json.cpp:2110:27: portability: Casting between unsigned char * and double * which have an incompatible binary data representation. [invalidPointerCast]
                    pv = *reinterpret_cast<double*>(buf);
                          ^
Shared/Magic/zsign/common/json.cpp:2128:52: portability: Casting between unsigned char * and double * which have an incompatible binary data representation. [invalidPointerCast]
                pv.assignDate(static_cast<time_t>(*reinterpret_cast<double*>(buf)) + 978278400);
                                                   ^
Shared/Magic/zsign/common/json.cpp:1975:13: style: The scope of the variable 'tmp' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint8_t tmp = 0;
            ^
Shared/Magic/zsign/common/json.cpp:2012:14: style: The scope of the variable 'wc' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it's safe to move 'int i = 0;' here
        for (int n = 0; n < 10; ++n) {
            // it is possible but not safe to move 'int i = 0;' here
            do_something(&i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level. [variableScope]
    uint16_t wc = 0;
             ^
Shared/Magic/zsign/common/json.cpp:754:45: style: The unsigned expression 'len' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (NULL == file || NULL == data || len <= 0) {
                                            ^
Shared/Magic/zsign/common/json.cpp:1492:33: style: inconclusive: Function 'v2s' argument 1 names different: declaration 'val' definition 'pstr'. [funcArgNamesDifferent]
string JWriter::v2s(const char *pstr) {
                                ^
Shared/Magic/zsign/common/json.h:302:35: note: Function 'v2s' argument 1 names different: declaration 'val' definition 'pstr'.
    static string v2s(const char *val);
                                  ^
Shared/Magic/zsign/common/json.cpp:1492:33: note: Function 'v2s' argument 1 names different: declaration 'val' definition 'pstr'.
string JWriter::v2s(const char *pstr) {
                                ^
Shared/Magic/zsign/common/json.cpp:1550:44: style: inconclusive: Function 'vstring2s' argument 1 names different: declaration 'val' definition 'pstr'. [funcArgNamesDifferent]
std::string JWriter::vstring2s(const char *pstr) { return string("\\\"") + pstr + "\\\""; }
                                           ^
Shared/Magic/zsign/common/json.h:304:41: note: Function 'vstring2s' argument 1 names different: declaration 'val' definition 'pstr'.
    static string vstring2s(const char *val);
                                        ^
Shared/Magic/zsign/common/json.cpp:1550:44: note: Function 'vstring2s' argument 1 names different: declaration 'val' definition 'pstr'.
std::string JWriter::vstring2s(const char *pstr) { return string("\\\"") + pstr + "\\\""; }
                                           ^
Shared/Magic/zsign/common/json.cpp:1608:33: style: inconclusive: Function 'readValue' argument 1 names different: declaration 'jval' definition 'pval'. [funcArgNamesDifferent]
bool PReader::readValue(JValue &pval, Token &token) {
                                ^
Shared/Magic/zsign/common/json.h:360:28: note: Function 'readValue' argument 1 names different: declaration 'jval' definition 'pval'.
    bool readValue(JValue &jval, Token &token);
                           ^
Shared/Magic/zsign/common/json.cpp:1608:33: note: Function 'readValue' argument 1 names different: declaration 'jval' definition 'pval'.
bool PReader::readValue(JValue &pval, Token &token) {
                                ^
Shared/Magic/zsign/common/json.cpp:1827:38: style: inconclusive: Function 'readDictionary' argument 1 names different: declaration 'jval' definition 'pval'. [funcArgNamesDifferent]
bool PReader::readDictionary(JValue &pval) {
                                     ^
Shared/Magic/zsign/common/json.h:365:33: note: Function 'readDictionary' argument 1 names different: declaration 'jval' definition 'pval'.
    bool readDictionary(JValue &jval);
                                ^
Shared/Magic/zsign/common/json.cpp:1827:38: note: Function 'readDictionary' argument 1 names different: declaration 'jval' definition 'pval'.
bool PReader::readDictionary(JValue &pval) {
                                     ^
Shared/Magic/zsign/common/json.cpp:1855:33: style: inconclusive: Function 'readArray' argument 1 names different: declaration 'jval' definition 'pval'. [funcArgNamesDifferent]
bool PReader::readArray(JValue &pval) {
                                ^
Shared/Magic/zsign/common/json.h:361:28: note: Function 'readArray' argument 1 names different: declaration 'jval' definition 'pval'.
    bool readArray(JValue &jval);
                           ^
Shared/Magic/zsign/common/json.cpp:1855:33: note: Function 'readArray' argument 1 names different: declaration 'jval' definition 'pval'.
bool PReader::readArray(JValue &pval) {
                                ^
Shared/Magic/zsign/common/json.cpp:1874:50: style: inconclusive: Function 'decodeNumber' argument 2 names different: declaration 'jval' definition 'pval'. [funcArgNamesDifferent]
bool PReader::decodeNumber(Token &token, JValue &pval) {
                                                 ^
Shared/Magic/zsign/common/json.h:369:45: note: Function 'decodeNumber' argument 2 names different: declaration 'jval' definition 'pval'.
    bool decodeNumber(Token &token, JValue &jval);
                                            ^
Shared/Magic/zsign/common/json.cpp:1874:50: note: Function 'decodeNumber' argument 2 names different: declaration 'jval' definition 'pval'.
bool PReader::decodeNumber(Token &token, JValue &pval) {
                                                 ^
Shared/Magic/zsign/common/json.cpp:1896:50: style: inconclusive: Function 'decodeDouble' argument 2 names different: declaration 'jval' definition 'pval'. [funcArgNamesDifferent]
bool PReader::decodeDouble(Token &token, JValue &pval) {
                                                 ^
Shared/Magic/zsign/common/json.h:371:45: note: Function 'decodeDouble' argument 2 names different: declaration 'jval' definition 'pval'.
    bool decodeDouble(Token &token, JValue &jval);
                                            ^
Shared/Magic/zsign/common/json.cpp:1896:50: note: Function 'decodeDouble' argument 2 names different: declaration 'jval' definition 'pval'.
bool PReader::decodeDouble(Token &token, JValue &pval) {
                                                 ^
Shared/Magic/zsign/common/json.cpp:1912:50: style: inconclusive: Function 'decodeString' argument 2 names different: declaration 'decoded' definition 'strdec'. [funcArgNamesDifferent]
bool PReader::decodeString(Token &token, string &strdec, bool filter) {
                                                 ^
Shared/Magic/zsign/common/json.h:370:45: note: Function 'decodeString' argument 2 names different: declaration 'decoded' definition 'strdec'.
    bool decodeString(Token &token, string &decoded, bool filter = true);
                                            ^
Shared/Magic/zsign/common/json.cpp:1912:50: note: Function 'decodeString' argument 2 names different: declaration 'decoded' definition 'strdec'.
bool PReader::decodeString(Token &token, string &strdec, bool filter) {
                                                 ^
Shared/Magic/zsign/common/json.cpp:1001:18: style: Local variable 'c' shadows outer variable [shadowVariable]
            char c = GetNextChar();
                 ^
Shared/Magic/zsign/common/json.cpp:998:10: note: Shadowed declaration
    char c = GetNextChar();
         ^
Shared/Magic/zsign/common/json.cpp:1001:18: note: Shadow variable
            char c = GetNextChar();
                 ^
Shared/Magic/zsign/common/json.cpp:1008:18: style: Local variable 'c' shadows outer variable [shadowVariable]
            char c = GetNextChar();
                 ^
Shared/Magic/zsign/common/json.cpp:998:10: note: Shadowed declaration
    char c = GetNextChar();
         ^
Shared/Magic/zsign/common/json.cpp:1008:18: note: Shadow variable
            char c = GetNextChar();
                 ^
Shared/Magic/zsign/common/json.cpp:518:27: style: Parameter 'jv' can be declared with const [constParameter]
bool JValue::join(JValue &jv) {
                          ^
Shared/Magic/zsign/common/json.cpp:538:29: style: Parameter 'jv' can be declared with const [constParameter]
bool JValue::append(JValue &jv) {
                            ^
Shared/Magic/zsign/common/json.cpp:1912:35: style: Parameter 'token' can be declared with const [constParameter]
bool PReader::decodeString(Token &token, string &strdec, bool filter) {
                                  ^
Shared/Magic/zsign/common/json.cpp:1975:17: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
    uint8_t tmp = 0;
                ^
Shared/Magic/zsign/common/json.cpp:2012:17: style: Variable 'wc' is assigned a value that is never used. [unreadVariable]
    uint16_t wc = 0;
                ^
Shared/Magic/zsign/common/json.cpp:460:32: performance: Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code. [postfixOperator]
        for (; itbeg != itend; itbeg++) {
                               ^
Shared/Magic/zsign/common/json.cpp:593:0: style: The function 'assignDateString' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:505:0: style: The function 'back' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:492:0: style: The function 'front' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:518:0: style: The function 'join' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:804:0: style: The function 'readPListPath' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:794:0: style: The function 'readPath' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:834:0: style: The function 'styleWritePath' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:1550:0: style: The function 'vstring2s' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:824:0: style: The function 'writePListPath' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/json.cpp:814:0: style: The function 'writePath' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

Shared/Magic/zsign/common/common.cpp:40:32: style: inconclusive: Function 'IsRegularFile' argument 1 names different: declaration 'szFile' definition 'file'. [funcArgNamesDifferent]
bool IsRegularFile(const char *file) {
                               ^
Shared/Magic/zsign/common/common.h:61:32: note: Function 'IsRegularFile' argument 1 names different: declaration 'szFile' definition 'file'.
bool IsRegularFile(const char *szFile);
                               ^
Shared/Magic/zsign/common/common.cpp:40:32: note: Function 'IsRegularFile' argument 1 names different: declaration 'szFile' definition 'file'.
bool IsRegularFile(const char *file) {
                               ^
Shared/Magic/zsign/common/common.cpp:100:24: style: Parameter 'strData' can be declared with const [constParameter]
bool WriteFile(string &strData, const char *szFormatPath, ...) {
                       ^
Shared/Magic/zsign/common/common.cpp:301:18: style: Variable 'fsize' is assigned a value that is never used. [unreadVariable]
    double fsize = 0;
                 ^
Shared/Magic/zsign/common/common.cpp:43:0: information: Skipping configuration 'S_IFMT;S_IFREG;S_ISREG' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    return S_ISREG(info.st_mode);
^
Shared/Magic/zsign/common/common.cpp:276:0: information: Skipping configuration 'S_IFMT;S_IFREG;S_ISREG' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        if (S_ISREG(stbuf.st_mode)) {
^
Shared/Magic/zsign/common/common.cpp:398:0: style: The function 'ByteAlign' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:187:0: style: The function 'CreateFolderV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:682:0: style: The function 'Debug' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:689:0: style: The function 'DebugV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:246:0: style: The function 'GetCanonicalizePath' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:298:0: style: The function 'GetFileSizeString' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:293:0: style: The function 'GetFileSizeV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:331:0: style: The function 'GetUnixStamp' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:697:0: style: The function 'IsDebug' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:227:0: style: The function 'IsFileExistsV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:171:0: style: The function 'IsFolderV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:321:0: style: The function 'IsPathSuffix' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:40:0: style: The function 'IsRegularFile' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:232:0: style: The function 'IsZipFile' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:563:0: style: The function 'Print' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:454:0: style: The function 'PrintDataSHASum' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:570:0: style: The function 'PrintResult' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:215:0: style: The function 'RemoveFileV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:208:0: style: The function 'RemoveFolderV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:429:0: style: The function 'SHA1Text' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:505:0: style: The function 'SHASumBase64' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:515:0: style: The function 'SHASumBase64File' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:579:0: style: The function 'SetLogLever' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:400:0: style: The function 'StringFormat' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:416:0: style: The function 'StringSplit' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:634:0: style: The function 'SuccessV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:343:0: style: The function 'SystemExec' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:650:0: style: The function 'Warn' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:658:0: style: The function 'WarnV' is never used. [unusedFunction]

^
Shared/Magic/zsign/common/common.cpp:383:0: style: The function '_Swap' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingInclude]

nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

